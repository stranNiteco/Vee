//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/work/Vee\Vee.g4 by ANTLR 4.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6")]
[System.CLSCompliant(false)]
public partial class VeeParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		LBracket=1, RBracket=2, LBrace=3, RBrace=4, LParen=5, RParen=6, Comma=7, 
		Colon=8, Range=9, Arrow=10, Lambda=11, Pow=12, Multiply=13, Divide=14, 
		Modulo=15, Plus=16, Minus=17, Eq=18, Neq=19, Lt=20, Gt=21, Lte=22, Gte=23, 
		Pipe=24, RPipe=25, Dot=26, Concat=27, ComposeRight=28, ComposeLeft=29, 
		ComposeAnd=30, ComposeOr=31, Inverse=32, AndAlso=33, OrElse=34, Not=35, 
		TypeOf=36, Let=37, In=38, If=39, Is=40, When=41, Then=42, Else=43, True=44, 
		False=45, New=46, As=47, Type=48, StringType=49, NumberType=50, BooleanType=51, 
		EnumType=52, TupleType=53, RecordType=54, ListType=55, MapType=56, TaskType=57, 
		OptionType=58, UnitType=59, SomeCase=60, NoneCase=61, ResultCase=62, ErrorCase=63, 
		Number=64, Name=65, Wildcard=66, String=67, WS=68;
	public const int
		RULE_root = 0, RULE_type = 1, RULE_typeAnnotation = 2, RULE_typeName = 3, 
		RULE_expression = 4, RULE_constant = 5, RULE_nums = 6, RULE_recordPair = 7, 
		RULE_mapItems = 8, RULE_mapPair = 9, RULE_mapItemType = 10, RULE_listItems = 11, 
		RULE_member = 12, RULE_argument = 13, RULE_declarations = 14, RULE_declaration = 15, 
		RULE_extraction = 16, RULE_alias = 17, RULE_condition = 18, RULE_match = 19, 
		RULE_pattern = 20, RULE_capture = 21, RULE_keyPattern = 22, RULE_fieldPattern = 23, 
		RULE_rest = 24, RULE_lambdaParams = 25, RULE_lambdaBody = 26, RULE_operators = 27, 
		RULE_binaryOperators = 28, RULE_unaryOperators = 29;
	public static readonly string[] ruleNames = {
		"root", "type", "typeAnnotation", "typeName", "expression", "constant", 
		"nums", "recordPair", "mapItems", "mapPair", "mapItemType", "listItems", 
		"member", "argument", "declarations", "declaration", "extraction", "alias", 
		"condition", "match", "pattern", "capture", "keyPattern", "fieldPattern", 
		"rest", "lambdaParams", "lambdaBody", "operators", "binaryOperators", 
		"unaryOperators"
	};

	private static readonly string[] _LiteralNames = {
		null, "'['", "']'", "'{'", "'}'", "'('", "')'", "','", "':'", "'..'", 
		"'->'", "'\\'", "'^'", "'*'", "'/'", "'%'", "'+'", "'-'", "'='", "'!='", 
		"'<'", "'>'", "'<='", "'>='", "'|'", "'|>'", "'.'", "'::'", "'>>'", "'<<'", 
		"'&&'", "'||'", "'!'", "'and'", "'or'", "'not'", "'typeof'", "'let'", 
		"'in'", "'if'", "'is'", "'when'", "'then'", "'else'", "'true'", "'false'", 
		"'new'", "'as'", "'type'", "'string'", "'number'", "'boolean'", "'enum'", 
		"'tuple'", "'record'", "'list'", "'map'", "'task'", "'option'", "'unit'", 
		"'some'", "'none'", "'result'", "'error'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "LBracket", "RBracket", "LBrace", "RBrace", "LParen", "RParen", 
		"Comma", "Colon", "Range", "Arrow", "Lambda", "Pow", "Multiply", "Divide", 
		"Modulo", "Plus", "Minus", "Eq", "Neq", "Lt", "Gt", "Lte", "Gte", "Pipe", 
		"RPipe", "Dot", "Concat", "ComposeRight", "ComposeLeft", "ComposeAnd", 
		"ComposeOr", "Inverse", "AndAlso", "OrElse", "Not", "TypeOf", "Let", "In", 
		"If", "Is", "When", "Then", "Else", "True", "False", "New", "As", "Type", 
		"StringType", "NumberType", "BooleanType", "EnumType", "TupleType", "RecordType", 
		"ListType", "MapType", "TaskType", "OptionType", "UnitType", "SomeCase", 
		"NoneCase", "ResultCase", "ErrorCase", "Number", "Name", "Wildcard", "String", 
		"WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Vee.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	static VeeParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

	public VeeParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class RootContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VeeParser.Eof, 0); }
		public DeclarationsContext declarations() {
			return GetRuleContext<DeclarationsContext>(0);
		}
		public ITerminalNode In() { return GetToken(VeeParser.In, 0); }
		public RootContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_root; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoot(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RootContext root() {
		RootContext _localctx = new RootContext(Context, State);
		EnterRule(_localctx, 0, RULE_root);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 63;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Let) {
				{
				State = 60; declarations();
				State = 61; Match(In);
				}
			}

			State = 65; expression(0);
			State = 66; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
	 
		public TypeContext() { }
		public virtual void CopyFrom(TypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class NamedTypeContext : TypeContext {
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public NamedTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AliasTypeContext : TypeContext {
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public TypeAnnotationContext typeAnnotation() {
			return GetRuleContext<TypeAnnotationContext>(0);
		}
		public AliasTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionTypeContext : TypeContext {
		public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode Arrow() { return GetToken(VeeParser.Arrow, 0); }
		public FunctionTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParameterizedTypeContext : TypeContext {
		public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public ParameterizedTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BuiltinTypeContext : TypeContext {
		public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		public BuiltinTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltinType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ProductTypeContext : TypeContext {
		public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode Comma() { return GetToken(VeeParser.Comma, 0); }
		public ProductTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProductType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SumTypeContext : TypeContext {
		public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode Pipe() { return GetToken(VeeParser.Pipe, 0); }
		public SumTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSumType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpenTypeContext : TypeContext {
		public ITerminalNode Wildcard() { return GetToken(VeeParser.Wildcard, 0); }
		public OpenTypeContext(TypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpenType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		return type(0);
	}

	private TypeContext type(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TypeContext _localctx = new TypeContext(Context, _parentState);
		TypeContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_type, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 74;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				{
				_localctx = new BuiltinTypeContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 69; typeName();
				}
				break;
			case 2:
				{
				_localctx = new NamedTypeContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 70; Match(Name);
				}
				break;
			case 3:
				{
				_localctx = new OpenTypeContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 71; Match(Wildcard);
				}
				break;
			case 4:
				{
				_localctx = new AliasTypeContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 72; Match(Name);
				State = 73; typeAnnotation();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 92;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 90;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
					case 1:
						{
						_localctx = new FunctionTypeContext(new TypeContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_type);
						State = 76;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 77; Match(Arrow);
						State = 78; type(4);
						}
						break;
					case 2:
						{
						_localctx = new ProductTypeContext(new TypeContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_type);
						State = 79;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 80; Match(Comma);
						State = 81; type(3);
						}
						break;
					case 3:
						{
						_localctx = new SumTypeContext(new TypeContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_type);
						State = 82;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 83; Match(Pipe);
						State = 84; type(2);
						}
						break;
					case 4:
						{
						_localctx = new ParameterizedTypeContext(new TypeContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_type);
						State = 85;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 86; Match(LParen);
						State = 87; type(0);
						State = 88; Match(RParen);
						}
						break;
					}
					} 
				}
				State = 94;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeAnnotationContext : ParserRuleContext {
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeAnnotationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeAnnotation; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeAnnotationContext typeAnnotation() {
		TypeAnnotationContext _localctx = new TypeAnnotationContext(Context, State);
		EnterRule(_localctx, 4, RULE_typeAnnotation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 95; Match(Colon);
			State = 96; type(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		public ITerminalNode StringType() { return GetToken(VeeParser.StringType, 0); }
		public ITerminalNode NumberType() { return GetToken(VeeParser.NumberType, 0); }
		public ITerminalNode BooleanType() { return GetToken(VeeParser.BooleanType, 0); }
		public ITerminalNode ListType() { return GetToken(VeeParser.ListType, 0); }
		public ITerminalNode MapType() { return GetToken(VeeParser.MapType, 0); }
		public ITerminalNode TupleType() { return GetToken(VeeParser.TupleType, 0); }
		public ITerminalNode RecordType() { return GetToken(VeeParser.RecordType, 0); }
		public ITerminalNode EnumType() { return GetToken(VeeParser.EnumType, 0); }
		public ITerminalNode TaskType() { return GetToken(VeeParser.TaskType, 0); }
		public ITerminalNode OptionType() { return GetToken(VeeParser.OptionType, 0); }
		public ITerminalNode UnitType() { return GetToken(VeeParser.UnitType, 0); }
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 6, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 98;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << StringType) | (1L << NumberType) | (1L << BooleanType) | (1L << EnumType) | (1L << TupleType) | (1L << RecordType) | (1L << ListType) | (1L << MapType) | (1L << TaskType) | (1L << OptionType) | (1L << UnitType))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PatternMathchingContext : ExpressionContext {
		public ITerminalNode If() { return GetToken(VeeParser.If, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Is() { return GetToken(VeeParser.Is, 0); }
		public MatchContext[] match() {
			return GetRuleContexts<MatchContext>();
		}
		public MatchContext match(int i) {
			return GetRuleContext<MatchContext>(i);
		}
		public ITerminalNode[] Pipe() { return GetTokens(VeeParser.Pipe); }
		public ITerminalNode Pipe(int i) {
			return GetToken(VeeParser.Pipe, i);
		}
		public ITerminalNode Else() { return GetToken(VeeParser.Else, 0); }
		public PatternMathchingContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternMathching(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AccessContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Dot() { return GetToken(VeeParser.Dot, 0); }
		public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public AccessContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAccess(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConditionalContext : ExpressionContext {
		public ITerminalNode If() { return GetToken(VeeParser.If, 0); }
		public ConditionContext[] condition() {
			return GetRuleContexts<ConditionContext>();
		}
		public ConditionContext condition(int i) {
			return GetRuleContext<ConditionContext>(i);
		}
		public ITerminalNode Else() { return GetToken(VeeParser.Else, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode[] Pipe() { return GetTokens(VeeParser.Pipe); }
		public ITerminalNode Pipe(int i) {
			return GetToken(VeeParser.Pipe, i);
		}
		public ConditionalContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Plus() { return GetToken(VeeParser.Plus, 0); }
		public ITerminalNode Minus() { return GetToken(VeeParser.Minus, 0); }
		public UnaryContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicativeContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Multiply() { return GetToken(VeeParser.Multiply, 0); }
		public ITerminalNode Divide() { return GetToken(VeeParser.Divide, 0); }
		public ITerminalNode Modulo() { return GetToken(VeeParser.Modulo, 0); }
		public MultiplicativeContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicative(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TupleContext : ExpressionContext {
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public TupleContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LambdaContext : ExpressionContext {
		public ITerminalNode Lambda() { return GetToken(VeeParser.Lambda, 0); }
		public LambdaParamsContext lambdaParams() {
			return GetRuleContext<LambdaParamsContext>(0);
		}
		public ITerminalNode Arrow() { return GetToken(VeeParser.Arrow, 0); }
		public LambdaBodyContext lambdaBody() {
			return GetRuleContext<LambdaBodyContext>(0);
		}
		public LambdaContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLambda(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCompositionContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode ComposeLeft() { return GetToken(VeeParser.ComposeLeft, 0); }
		public ITerminalNode ComposeRight() { return GetToken(VeeParser.ComposeRight, 0); }
		public FunctionCompositionContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionComposition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RecordContext : ExpressionContext {
		public ITerminalNode LBrace() { return GetToken(VeeParser.LBrace, 0); }
		public RecordPairContext[] recordPair() {
			return GetRuleContexts<RecordPairContext>();
		}
		public RecordPairContext recordPair(int i) {
			return GetRuleContext<RecordPairContext>(i);
		}
		public ITerminalNode RBrace() { return GetToken(VeeParser.RBrace, 0); }
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public RecordContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PredicateCompositionContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode ComposeAnd() { return GetToken(VeeParser.ComposeAnd, 0); }
		public ITerminalNode ComposeOr() { return GetToken(VeeParser.ComposeOr, 0); }
		public PredicateCompositionContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPredicateComposition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PipeContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPipe() { return GetToken(VeeParser.RPipe, 0); }
		public PipeContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPipe(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ValueContext : ExpressionContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ValueContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MapContext : ExpressionContext {
		public ITerminalNode LBrace() { return GetToken(VeeParser.LBrace, 0); }
		public ITerminalNode RBrace() { return GetToken(VeeParser.RBrace, 0); }
		public MapItemsContext mapItems() {
			return GetRuleContext<MapItemsContext>(0);
		}
		public MapItemTypeContext mapItemType() {
			return GetRuleContext<MapItemTypeContext>(0);
		}
		public MapContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PredicateInversionContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Inverse() { return GetToken(VeeParser.Inverse, 0); }
		public PredicateInversionContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPredicateInversion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EqualityContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Eq() { return GetToken(VeeParser.Eq, 0); }
		public ITerminalNode Neq() { return GetToken(VeeParser.Neq, 0); }
		public EqualityContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeofContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TypeOf() { return GetToken(VeeParser.TypeOf, 0); }
		public TypeofContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeof(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalNotContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Not() { return GetToken(VeeParser.Not, 0); }
		public LogicalNotContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalNot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ListContext : ExpressionContext {
		public ITerminalNode LBracket() { return GetToken(VeeParser.LBracket, 0); }
		public ITerminalNode RBracket() { return GetToken(VeeParser.RBracket, 0); }
		public NumsContext nums() {
			return GetRuleContext<NumsContext>(0);
		}
		public ListItemsContext listItems() {
			return GetRuleContext<ListItemsContext>(0);
		}
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ListContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitList(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ComparisionContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Lt() { return GetToken(VeeParser.Lt, 0); }
		public ITerminalNode Lte() { return GetToken(VeeParser.Lte, 0); }
		public ITerminalNode Gt() { return GetToken(VeeParser.Gt, 0); }
		public ITerminalNode Gte() { return GetToken(VeeParser.Gte, 0); }
		public ComparisionContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparision(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GroupingContext : ExpressionContext {
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public GroupingContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode AndAlso() { return GetToken(VeeParser.AndAlso, 0); }
		public ITerminalNode OrElse() { return GetToken(VeeParser.OrElse, 0); }
		public LogicalContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OperatorLambdaContext : ExpressionContext {
		public ITerminalNode[] Pipe() { return GetTokens(VeeParser.Pipe); }
		public ITerminalNode Pipe(int i) {
			return GetToken(VeeParser.Pipe, i);
		}
		public OperatorsContext operators() {
			return GetRuleContext<OperatorsContext>(0);
		}
		public OperatorLambdaContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorLambda(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AdditiveContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Plus() { return GetToken(VeeParser.Plus, 0); }
		public ITerminalNode Minus() { return GetToken(VeeParser.Minus, 0); }
		public AdditiveContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditive(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExponentiationContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Pow() { return GetToken(VeeParser.Pow, 0); }
		public ExponentiationContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExponentiation(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InvocationContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public InvocationContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInvocation(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConcatenationContext : ExpressionContext {
		public ExpressionContext l;
		public IToken op;
		public ExpressionContext r;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Concat() { return GetToken(VeeParser.Concat, 0); }
		public ConcatenationContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableContext : ExpressionContext {
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public VariableContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 8;
		EnterRecursionRule(_localctx, 8, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 190;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				{
				_localctx = new ValueContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 101; constant();
				}
				break;
			case 2:
				{
				_localctx = new VariableContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 102; Match(Name);
				}
				break;
			case 3:
				{
				_localctx = new TupleContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 103; Match(LParen);
				State = 104; expression(0);
				State = 107;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 105; Match(Comma);
					State = 106; expression(0);
					}
					}
					State = 109;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==Comma );
				State = 111; Match(RParen);
				}
				break;
			case 4:
				{
				_localctx = new RecordContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 113; Match(LBrace);
				State = 114; recordPair();
				State = 119;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 115; Match(Comma);
					State = 116; recordPair();
					}
					}
					State = 121;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 122; Match(RBrace);
				}
				break;
			case 5:
				{
				_localctx = new MapContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 124; Match(LBrace);
				State = 128;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
				case 1:
					{
					State = 125; mapItems();
					}
					break;
				case 2:
					{
					State = 126; mapItemType();
					}
					break;
				case 3:
					{
					}
					break;
				}
				State = 130; Match(RBrace);
				}
				break;
			case 6:
				{
				_localctx = new ListContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 131; Match(LBracket);
				State = 136;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
				case 1:
					{
					State = 132; nums();
					}
					break;
				case 2:
					{
					State = 133; listItems();
					}
					break;
				case 3:
					{
					State = 134; type(0);
					}
					break;
				case 4:
					{
					}
					break;
				}
				State = 138; Match(RBracket);
				}
				break;
			case 7:
				{
				_localctx = new GroupingContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 139; Match(LParen);
				State = 140; expression(0);
				State = 141; Match(RParen);
				}
				break;
			case 8:
				{
				_localctx = new LogicalNotContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 143; ((LogicalNotContext)_localctx).op = Match(Not);
				State = 144; expression(18);
				}
				break;
			case 9:
				{
				_localctx = new PredicateInversionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 145; ((PredicateInversionContext)_localctx).op = Match(Inverse);
				State = 146; expression(17);
				}
				break;
			case 10:
				{
				_localctx = new UnaryContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 147;
				((UnaryContext)_localctx).op = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==Plus || _la==Minus) ) {
					((UnaryContext)_localctx).op = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 148; expression(16);
				}
				break;
			case 11:
				{
				_localctx = new TypeofContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 149; ((TypeofContext)_localctx).op = Match(TypeOf);
				State = 150; expression(15);
				}
				break;
			case 12:
				{
				_localctx = new OperatorLambdaContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 151; Match(Pipe);
				State = 152; operators();
				State = 153; Match(Pipe);
				}
				break;
			case 13:
				{
				_localctx = new LambdaContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 155; Match(Lambda);
				State = 156; lambdaParams();
				State = 157; Match(Arrow);
				State = 158; lambdaBody();
				}
				break;
			case 14:
				{
				_localctx = new ConditionalContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 160; Match(If);
				State = 161; condition();
				State = 166;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Pipe) {
					{
					{
					State = 162; Match(Pipe);
					State = 163; condition();
					}
					}
					State = 168;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 169; Match(Else);
				State = 170; expression(2);
				}
				break;
			case 15:
				{
				_localctx = new PatternMathchingContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 172; Match(If);
				State = 173; expression(0);
				State = 174; Match(Is);
				State = 176;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Pipe) {
					{
					State = 175; Match(Pipe);
					}
				}

				State = 178; match();
				State = 183;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,10,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 179; Match(Pipe);
						State = 180; match();
						}
						} 
					}
					State = 185;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,10,Context);
				}
				State = 188;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
				case 1:
					{
					State = 186; Match(Else);
					State = 187; expression(0);
					}
					break;
				}
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 240;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 238;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
					case 1:
						{
						_localctx = new ExponentiationContext(new ExpressionContext(_parentctx, _parentState));
						((ExponentiationContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 192;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 193; ((ExponentiationContext)_localctx).op = Match(Pow);
						State = 194; ((ExponentiationContext)_localctx).r = expression(15);
						}
						break;
					case 2:
						{
						_localctx = new MultiplicativeContext(new ExpressionContext(_parentctx, _parentState));
						((MultiplicativeContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 195;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 196;
						((MultiplicativeContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Multiply) | (1L << Divide) | (1L << Modulo))) != 0)) ) {
							((MultiplicativeContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 197; ((MultiplicativeContext)_localctx).r = expression(14);
						}
						break;
					case 3:
						{
						_localctx = new AdditiveContext(new ExpressionContext(_parentctx, _parentState));
						((AdditiveContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 198;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 199;
						((AdditiveContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==Plus || _la==Minus) ) {
							((AdditiveContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 200; ((AdditiveContext)_localctx).r = expression(13);
						}
						break;
					case 4:
						{
						_localctx = new EqualityContext(new ExpressionContext(_parentctx, _parentState));
						((EqualityContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 201;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 202;
						((EqualityContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==Eq || _la==Neq) ) {
							((EqualityContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 203; ((EqualityContext)_localctx).r = expression(12);
						}
						break;
					case 5:
						{
						_localctx = new ComparisionContext(new ExpressionContext(_parentctx, _parentState));
						((ComparisionContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 204;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 205;
						((ComparisionContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Lt) | (1L << Gt) | (1L << Lte) | (1L << Gte))) != 0)) ) {
							((ComparisionContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 206; ((ComparisionContext)_localctx).r = expression(11);
						}
						break;
					case 6:
						{
						_localctx = new LogicalContext(new ExpressionContext(_parentctx, _parentState));
						((LogicalContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 207;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 208;
						((LogicalContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==AndAlso || _la==OrElse) ) {
							((LogicalContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 209; ((LogicalContext)_localctx).r = expression(10);
						}
						break;
					case 7:
						{
						_localctx = new ConcatenationContext(new ExpressionContext(_parentctx, _parentState));
						((ConcatenationContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 210;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 211; ((ConcatenationContext)_localctx).op = Match(Concat);
						State = 212; ((ConcatenationContext)_localctx).r = expression(9);
						}
						break;
					case 8:
						{
						_localctx = new PredicateCompositionContext(new ExpressionContext(_parentctx, _parentState));
						((PredicateCompositionContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 213;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 214;
						((PredicateCompositionContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ComposeAnd || _la==ComposeOr) ) {
							((PredicateCompositionContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 215; ((PredicateCompositionContext)_localctx).r = expression(8);
						}
						break;
					case 9:
						{
						_localctx = new FunctionCompositionContext(new ExpressionContext(_parentctx, _parentState));
						((FunctionCompositionContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 216;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 217;
						((FunctionCompositionContext)_localctx).op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ComposeRight || _la==ComposeLeft) ) {
							((FunctionCompositionContext)_localctx).op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 218; ((FunctionCompositionContext)_localctx).r = expression(7);
						}
						break;
					case 10:
						{
						_localctx = new PipeContext(new ExpressionContext(_parentctx, _parentState));
						((PipeContext)_localctx).l = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 219;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 220; ((PipeContext)_localctx).op = Match(RPipe);
						State = 221; ((PipeContext)_localctx).r = expression(6);
						}
						break;
					case 11:
						{
						_localctx = new AccessContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 222;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 223; Match(Dot);
						State = 224; member();
						}
						break;
					case 12:
						{
						_localctx = new InvocationContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 225;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 226; Match(LParen);
						State = 228;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LBracket) | (1L << LBrace) | (1L << LParen) | (1L << Lambda) | (1L << Plus) | (1L << Minus) | (1L << Pipe) | (1L << Inverse) | (1L << Not) | (1L << TypeOf) | (1L << If) | (1L << True) | (1L << False))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (Number - 64)) | (1L << (Name - 64)) | (1L << (Wildcard - 64)) | (1L << (String - 64)))) != 0)) {
							{
							State = 227; argument();
							}
						}

						State = 234;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==Comma) {
							{
							{
							State = 230; Match(Comma);
							State = 231; argument();
							}
							}
							State = 236;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						State = 237; Match(RParen);
						}
						break;
					}
					} 
				}
				State = 242;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode True() { return GetToken(VeeParser.True, 0); }
		public ITerminalNode False() { return GetToken(VeeParser.False, 0); }
		public ITerminalNode Number() { return GetToken(VeeParser.Number, 0); }
		public ITerminalNode String() { return GetToken(VeeParser.String, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 10, RULE_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 243;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 44)) & ~0x3f) == 0 && ((1L << (_la - 44)) & ((1L << (True - 44)) | (1L << (False - 44)) | (1L << (Number - 44)) | (1L << (String - 44)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumsContext : ParserRuleContext {
		public IToken from;
		public IToken to;
		public ITerminalNode[] Range() { return GetTokens(VeeParser.Range); }
		public ITerminalNode Range(int i) {
			return GetToken(VeeParser.Range, i);
		}
		public ITerminalNode[] Number() { return GetTokens(VeeParser.Number); }
		public ITerminalNode Number(int i) {
			return GetToken(VeeParser.Number, i);
		}
		public ITerminalNode Plus() { return GetToken(VeeParser.Plus, 0); }
		public ITerminalNode Minus() { return GetToken(VeeParser.Minus, 0); }
		public NumsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nums; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNums(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumsContext nums() {
		NumsContext _localctx = new NumsContext(Context, State);
		EnterRule(_localctx, 12, RULE_nums);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 245; _localctx.from = Match(Number);
			State = 246; Match(Range);
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Plus || _la==Minus) {
				{
				State = 247;
				_la = TokenStream.LA(1);
				if ( !(_la==Plus || _la==Minus) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 248; Match(Number);
				State = 249; Match(Range);
				}
			}

			State = 252; _localctx.to = Match(Number);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordPairContext : ParserRuleContext {
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public RecordPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordPair; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecordPair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RecordPairContext recordPair() {
		RecordPairContext _localctx = new RecordPairContext(Context, State);
		EnterRule(_localctx, 14, RULE_recordPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 254; Match(Name);
			State = 255; Match(Colon);
			State = 256; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapItemsContext : ParserRuleContext {
		public MapPairContext[] mapPair() {
			return GetRuleContexts<MapPairContext>();
		}
		public MapPairContext mapPair(int i) {
			return GetRuleContext<MapPairContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public MapItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapItems; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapItems(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapItemsContext mapItems() {
		MapItemsContext _localctx = new MapItemsContext(Context, State);
		EnterRule(_localctx, 16, RULE_mapItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 258; mapPair();
			State = 263;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 259; Match(Comma);
				State = 260; mapPair();
				}
				}
				State = 265;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapPairContext : ParserRuleContext {
		public ITerminalNode LBracket() { return GetToken(VeeParser.LBracket, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RBracket() { return GetToken(VeeParser.RBracket, 0); }
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public MapPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapPair; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapPair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapPairContext mapPair() {
		MapPairContext _localctx = new MapPairContext(Context, State);
		EnterRule(_localctx, 18, RULE_mapPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 266; Match(LBracket);
			State = 267; expression(0);
			State = 268; Match(RBracket);
			State = 269; Match(Colon);
			State = 270; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapItemTypeContext : ParserRuleContext {
		public ITerminalNode LBracket() { return GetToken(VeeParser.LBracket, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode RBracket() { return GetToken(VeeParser.RBracket, 0); }
		public TypeAnnotationContext typeAnnotation() {
			return GetRuleContext<TypeAnnotationContext>(0);
		}
		public MapItemTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapItemType; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapItemType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapItemTypeContext mapItemType() {
		MapItemTypeContext _localctx = new MapItemTypeContext(Context, State);
		EnterRule(_localctx, 20, RULE_mapItemType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 272; Match(LBracket);
			State = 273; type(0);
			State = 274; Match(RBracket);
			State = 275; typeAnnotation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListItemsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public ListItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listItems; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListItems(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListItemsContext listItems() {
		ListItemsContext _localctx = new ListItemsContext(Context, State);
		EnterRule(_localctx, 22, RULE_listItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 277; expression(0);
			State = 282;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 278; Match(Comma);
				State = 279; expression(0);
				}
				}
				State = 284;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberContext : ParserRuleContext {
		public ITerminalNode LBracket() { return GetToken(VeeParser.LBracket, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RBracket() { return GetToken(VeeParser.RBracket, 0); }
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public MemberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_member; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMember(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberContext member() {
		MemberContext _localctx = new MemberContext(Context, State);
		EnterRule(_localctx, 24, RULE_member);
		try {
			State = 290;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LBracket:
				EnterOuterAlt(_localctx, 1);
				{
				State = 285; Match(LBracket);
				State = 286; expression(0);
				State = 287; Match(RBracket);
				}
				break;
			case Name:
				EnterOuterAlt(_localctx, 2);
				{
				State = 289; Match(Name);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public ITerminalNode Wildcard() { return GetToken(VeeParser.Wildcard, 0); }
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 26, RULE_argument);
		try {
			State = 298;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LBracket:
			case LBrace:
			case LParen:
			case Lambda:
			case Plus:
			case Minus:
			case Pipe:
			case Inverse:
			case Not:
			case TypeOf:
			case If:
			case True:
			case False:
			case Number:
			case Name:
			case String:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 294;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
				case 1:
					{
					State = 292; Match(Name);
					State = 293; Match(Colon);
					}
					break;
				}
				State = 296; expression(0);
				}
				}
				break;
			case Wildcard:
				EnterOuterAlt(_localctx, 2);
				{
				State = 297; Match(Wildcard);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationsContext : ParserRuleContext {
		public ITerminalNode Let() { return GetToken(VeeParser.Let, 0); }
		public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public DeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarations; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarations(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationsContext declarations() {
		DeclarationsContext _localctx = new DeclarationsContext(Context, State);
		EnterRule(_localctx, 28, RULE_declarations);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 300; Match(Let);
			State = 301; declaration();
			State = 306;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 302; Match(Comma);
					State = 303; declaration();
					}
					} 
				}
				State = 308;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			}
			State = 310;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Comma) {
				{
				State = 309; Match(Comma);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public ExtractionContext extraction() {
			return GetRuleContext<ExtractionContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 30, RULE_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 314;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Name:
				{
				State = 312; Match(Name);
				}
				break;
			case LBrace:
			case LParen:
				{
				State = 313; extraction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 316; Match(Colon);
			State = 317; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractionContext : ParserRuleContext {
		public ExtractionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extraction; } }
	 
		public ExtractionContext() { }
		public virtual void CopyFrom(ExtractionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class RecordExtractionContext : ExtractionContext {
		public ITerminalNode LBrace() { return GetToken(VeeParser.LBrace, 0); }
		public ITerminalNode[] Name() { return GetTokens(VeeParser.Name); }
		public ITerminalNode Name(int i) {
			return GetToken(VeeParser.Name, i);
		}
		public ITerminalNode RBrace() { return GetToken(VeeParser.RBrace, 0); }
		public AliasContext[] alias() {
			return GetRuleContexts<AliasContext>();
		}
		public AliasContext alias(int i) {
			return GetRuleContext<AliasContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public RecordExtractionContext(ExtractionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecordExtraction(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TupleExtractionContext : ExtractionContext {
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public ITerminalNode[] Name() { return GetTokens(VeeParser.Name); }
		public ITerminalNode Name(int i) {
			return GetToken(VeeParser.Name, i);
		}
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public TupleExtractionContext(ExtractionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleExtraction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtractionContext extraction() {
		ExtractionContext _localctx = new ExtractionContext(Context, State);
		EnterRule(_localctx, 32, RULE_extraction);
		int _la;
		try {
			State = 342;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LParen:
				_localctx = new TupleExtractionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 319; Match(LParen);
				State = 320; Match(Name);
				State = 323;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 321; Match(Comma);
					State = 322; Match(Name);
					}
					}
					State = 325;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==Comma );
				State = 327; Match(RParen);
				}
				break;
			case LBrace:
				_localctx = new RecordExtractionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 328; Match(LBrace);
				State = 329; Match(Name);
				State = 331;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==As) {
					{
					State = 330; alias();
					}
				}

				State = 338;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 333; Match(Comma);
					State = 334; Match(Name);
					State = 335; alias();
					}
					}
					State = 340;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 341; Match(RBrace);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasContext : ParserRuleContext {
		public ITerminalNode As() { return GetToken(VeeParser.As, 0); }
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public AliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasContext alias() {
		AliasContext _localctx = new AliasContext(Context, State);
		EnterRule(_localctx, 34, RULE_alias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 344; Match(As);
			State = 345; Match(Name);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Then() { return GetToken(VeeParser.Then, 0); }
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(Context, State);
		EnterRule(_localctx, 36, RULE_condition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 347; expression(0);
			State = 348; Match(Then);
			State = 349; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchContext : ParserRuleContext {
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public ITerminalNode Then() { return GetToken(VeeParser.Then, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode When() { return GetToken(VeeParser.When, 0); }
		public MatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_match; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchContext match() {
		MatchContext _localctx = new MatchContext(Context, State);
		EnterRule(_localctx, 38, RULE_match);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 351; pattern();
			State = 354;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==When) {
				{
				State = 352; Match(When);
				State = 353; expression(0);
				}
			}

			State = 356; Match(Then);
			State = 357; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternContext : ParserRuleContext {
		public PatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pattern; } }
	 
		public PatternContext() { }
		public virtual void CopyFrom(PatternContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ListPatternContext : PatternContext {
		public ITerminalNode LBracket() { return GetToken(VeeParser.LBracket, 0); }
		public ITerminalNode RBracket() { return GetToken(VeeParser.RBracket, 0); }
		public CaptureContext[] capture() {
			return GetRuleContexts<CaptureContext>();
		}
		public CaptureContext capture(int i) {
			return GetRuleContext<CaptureContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public RestContext rest() {
			return GetRuleContext<RestContext>(0);
		}
		public ListPatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListPattern(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NonePatternContext : PatternContext {
		public ITerminalNode NoneCase() { return GetToken(VeeParser.NoneCase, 0); }
		public NonePatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonePattern(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TuplePatternContext : PatternContext {
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public CaptureContext[] capture() {
			return GetRuleContexts<CaptureContext>();
		}
		public CaptureContext capture(int i) {
			return GetRuleContext<CaptureContext>(i);
		}
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public RestContext rest() {
			return GetRuleContext<RestContext>(0);
		}
		public TuplePatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuplePattern(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RecordPatternContext : PatternContext {
		public ITerminalNode LBrace() { return GetToken(VeeParser.LBrace, 0); }
		public FieldPatternContext[] fieldPattern() {
			return GetRuleContexts<FieldPatternContext>();
		}
		public FieldPatternContext fieldPattern(int i) {
			return GetRuleContext<FieldPatternContext>(i);
		}
		public ITerminalNode RBrace() { return GetToken(VeeParser.RBrace, 0); }
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public RestContext rest() {
			return GetRuleContext<RestContext>(0);
		}
		public RecordPatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecordPattern(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstantPatternContext : PatternContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ConstantPatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantPattern(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MapPatternContext : PatternContext {
		public ITerminalNode LBrace() { return GetToken(VeeParser.LBrace, 0); }
		public ITerminalNode RBrace() { return GetToken(VeeParser.RBrace, 0); }
		public KeyPatternContext[] keyPattern() {
			return GetRuleContexts<KeyPatternContext>();
		}
		public KeyPatternContext keyPattern(int i) {
			return GetRuleContext<KeyPatternContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public RestContext rest() {
			return GetRuleContext<RestContext>(0);
		}
		public MapPatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapPattern(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EnumPatternContext : PatternContext {
		public CaptureContext capture() {
			return GetRuleContext<CaptureContext>(0);
		}
		public ITerminalNode SomeCase() { return GetToken(VeeParser.SomeCase, 0); }
		public ITerminalNode ResultCase() { return GetToken(VeeParser.ResultCase, 0); }
		public ITerminalNode ErrorCase() { return GetToken(VeeParser.ErrorCase, 0); }
		public EnumPatternContext(PatternContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternContext pattern() {
		PatternContext _localctx = new PatternContext(Context, State);
		EnterRule(_localctx, 40, RULE_pattern);
		int _la;
		try {
			int _alt;
			State = 425;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
			case 1:
				_localctx = new TuplePatternContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 359; Match(LParen);
				State = 360; capture();
				State = 365;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 361; Match(Comma);
						State = 362; capture();
						}
						} 
					}
					State = 367;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
				}
				State = 370;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 368; Match(Comma);
					State = 369; rest();
					}
				}

				State = 372; Match(RParen);
				}
				break;
			case 2:
				_localctx = new RecordPatternContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 374; Match(LBrace);
				State = 375; fieldPattern();
				State = 380;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 376; Match(Comma);
						State = 377; fieldPattern();
						}
						} 
					}
					State = 382;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
				}
				State = 385;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 383; Match(Comma);
					State = 384; rest();
					}
				}

				State = 387; Match(RBrace);
				}
				break;
			case 3:
				_localctx = new ListPatternContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 389; Match(LBracket);
				State = 391;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LBracket) | (1L << LBrace) | (1L << LParen) | (1L << True) | (1L << False) | (1L << StringType) | (1L << NumberType) | (1L << BooleanType) | (1L << EnumType) | (1L << TupleType) | (1L << RecordType) | (1L << ListType) | (1L << MapType) | (1L << TaskType) | (1L << OptionType) | (1L << UnitType) | (1L << SomeCase) | (1L << NoneCase) | (1L << ResultCase) | (1L << ErrorCase))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (Number - 64)) | (1L << (Name - 64)) | (1L << (String - 64)))) != 0)) {
					{
					State = 390; capture();
					}
				}

				State = 397;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 393; Match(Comma);
						State = 394; capture();
						}
						} 
					}
					State = 399;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
				}
				State = 402;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 400; Match(Comma);
					State = 401; rest();
					}
				}

				State = 404; Match(RBracket);
				}
				break;
			case 4:
				_localctx = new MapPatternContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 405; Match(LBrace);
				State = 407;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LBracket) {
					{
					State = 406; keyPattern();
					}
				}

				State = 413;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,39,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 409; Match(Comma);
						State = 410; keyPattern();
						}
						} 
					}
					State = 415;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,39,Context);
				}
				State = 418;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 416; Match(Comma);
					State = 417; rest();
					}
				}

				State = 420; Match(RBrace);
				}
				break;
			case 5:
				_localctx = new EnumPatternContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 421;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << SomeCase) | (1L << ResultCase) | (1L << ErrorCase))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 422; capture();
				}
				break;
			case 6:
				_localctx = new NonePatternContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 423; Match(NoneCase);
				}
				break;
			case 7:
				_localctx = new ConstantPatternContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 424; constant();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaptureContext : ParserRuleContext {
		public CaptureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_capture; } }
	 
		public CaptureContext() { }
		public virtual void CopyFrom(CaptureContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypeCaptureContext : CaptureContext {
		public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		public AliasContext alias() {
			return GetRuleContext<AliasContext>(0);
		}
		public TypeCaptureContext(CaptureContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeCapture(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SubPatternCaptureContext : CaptureContext {
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public SubPatternCaptureContext(CaptureContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubPatternCapture(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableCaptureContext : CaptureContext {
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public VariableCaptureContext(CaptureContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableCapture(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaptureContext capture() {
		CaptureContext _localctx = new CaptureContext(Context, State);
		EnterRule(_localctx, 42, RULE_capture);
		int _la;
		try {
			State = 433;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Name:
				_localctx = new VariableCaptureContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 427; Match(Name);
				}
				break;
			case LBracket:
			case LBrace:
			case LParen:
			case True:
			case False:
			case SomeCase:
			case NoneCase:
			case ResultCase:
			case ErrorCase:
			case Number:
			case String:
				_localctx = new SubPatternCaptureContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 428; pattern();
				}
				break;
			case StringType:
			case NumberType:
			case BooleanType:
			case EnumType:
			case TupleType:
			case RecordType:
			case ListType:
			case MapType:
			case TaskType:
			case OptionType:
			case UnitType:
				_localctx = new TypeCaptureContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 429; typeName();
				State = 431;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==As) {
					{
					State = 430; alias();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeyPatternContext : ParserRuleContext {
		public ITerminalNode LBracket() { return GetToken(VeeParser.LBracket, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ITerminalNode RBracket() { return GetToken(VeeParser.RBracket, 0); }
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public CaptureContext capture() {
			return GetRuleContext<CaptureContext>(0);
		}
		public KeyPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyPattern; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeyPatternContext keyPattern() {
		KeyPatternContext _localctx = new KeyPatternContext(Context, State);
		EnterRule(_localctx, 44, RULE_keyPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 435; Match(LBracket);
			State = 436; constant();
			State = 437; Match(RBracket);
			State = 440;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Colon) {
				{
				State = 438; Match(Colon);
				State = 439; capture();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldPatternContext : ParserRuleContext {
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public ITerminalNode Colon() { return GetToken(VeeParser.Colon, 0); }
		public CaptureContext capture() {
			return GetRuleContext<CaptureContext>(0);
		}
		public FieldPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fieldPattern; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFieldPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FieldPatternContext fieldPattern() {
		FieldPatternContext _localctx = new FieldPatternContext(Context, State);
		EnterRule(_localctx, 46, RULE_fieldPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 442; Match(Name);
			State = 443; Match(Colon);
			State = 444; capture();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RestContext : ParserRuleContext {
		public ITerminalNode Range() { return GetToken(VeeParser.Range, 0); }
		public ITerminalNode Name() { return GetToken(VeeParser.Name, 0); }
		public RestContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rest; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRest(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RestContext rest() {
		RestContext _localctx = new RestContext(Context, State);
		EnterRule(_localctx, 48, RULE_rest);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 446; Match(Range);
			State = 447; Match(Name);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LambdaParamsContext : ParserRuleContext {
		public ITerminalNode[] Name() { return GetTokens(VeeParser.Name); }
		public ITerminalNode Name(int i) {
			return GetToken(VeeParser.Name, i);
		}
		public ITerminalNode LParen() { return GetToken(VeeParser.LParen, 0); }
		public ITerminalNode RParen() { return GetToken(VeeParser.RParen, 0); }
		public TypeAnnotationContext[] typeAnnotation() {
			return GetRuleContexts<TypeAnnotationContext>();
		}
		public TypeAnnotationContext typeAnnotation(int i) {
			return GetRuleContext<TypeAnnotationContext>(i);
		}
		public ITerminalNode[] Comma() { return GetTokens(VeeParser.Comma); }
		public ITerminalNode Comma(int i) {
			return GetToken(VeeParser.Comma, i);
		}
		public LambdaParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lambdaParams; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLambdaParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LambdaParamsContext lambdaParams() {
		LambdaParamsContext _localctx = new LambdaParamsContext(Context, State);
		EnterRule(_localctx, 50, RULE_lambdaParams);
		int _la;
		try {
			State = 466;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Name:
				EnterOuterAlt(_localctx, 1);
				{
				State = 449; Match(Name);
				}
				break;
			case LParen:
				EnterOuterAlt(_localctx, 2);
				{
				State = 450; Match(LParen);
				State = 451; Match(Name);
				State = 453;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Colon) {
					{
					State = 452; typeAnnotation();
					}
				}

				State = 462;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 455; Match(Comma);
					State = 456; Match(Name);
					State = 458;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==Colon) {
						{
						State = 457; typeAnnotation();
						}
					}

					}
					}
					State = 464;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 465; Match(RParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LambdaBodyContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DeclarationsContext declarations() {
			return GetRuleContext<DeclarationsContext>(0);
		}
		public LambdaBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lambdaBody; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLambdaBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LambdaBodyContext lambdaBody() {
		LambdaBodyContext _localctx = new LambdaBodyContext(Context, State);
		EnterRule(_localctx, 52, RULE_lambdaBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 469;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Let) {
				{
				State = 468; declarations();
				}
			}

			State = 471; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorsContext : ParserRuleContext {
		public ITerminalNode[] Wildcard() { return GetTokens(VeeParser.Wildcard); }
		public ITerminalNode Wildcard(int i) {
			return GetToken(VeeParser.Wildcard, i);
		}
		public BinaryOperatorsContext binaryOperators() {
			return GetRuleContext<BinaryOperatorsContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeAnnotationContext[] typeAnnotation() {
			return GetRuleContexts<TypeAnnotationContext>();
		}
		public TypeAnnotationContext typeAnnotation(int i) {
			return GetRuleContext<TypeAnnotationContext>(i);
		}
		public UnaryOperatorsContext unaryOperators() {
			return GetRuleContext<UnaryOperatorsContext>(0);
		}
		public ITerminalNode Dot() { return GetToken(VeeParser.Dot, 0); }
		public MemberContext member() {
			return GetRuleContext<MemberContext>(0);
		}
		public OperatorsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operators; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperators(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorsContext operators() {
		OperatorsContext _localctx = new OperatorsContext(Context, State);
		EnterRule(_localctx, 54, RULE_operators);
		int _la;
		try {
			State = 499;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,53,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 473; Match(Wildcard);
				State = 474; binaryOperators();
				State = 475; expression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 477; expression(0);
				State = 478; binaryOperators();
				State = 479; Match(Wildcard);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 481; Match(Wildcard);
				State = 483;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Colon) {
					{
					State = 482; typeAnnotation();
					}
				}

				State = 485; binaryOperators();
				State = 486; Match(Wildcard);
				State = 488;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Colon) {
					{
					State = 487; typeAnnotation();
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 490; unaryOperators();
				State = 491; Match(Wildcard);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 493; Match(Wildcard);
				State = 495;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Colon) {
					{
					State = 494; typeAnnotation();
					}
				}

				State = 497; Match(Dot);
				State = 498; member();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinaryOperatorsContext : ParserRuleContext {
		public ITerminalNode Pow() { return GetToken(VeeParser.Pow, 0); }
		public ITerminalNode Multiply() { return GetToken(VeeParser.Multiply, 0); }
		public ITerminalNode Divide() { return GetToken(VeeParser.Divide, 0); }
		public ITerminalNode Modulo() { return GetToken(VeeParser.Modulo, 0); }
		public ITerminalNode Plus() { return GetToken(VeeParser.Plus, 0); }
		public ITerminalNode Minus() { return GetToken(VeeParser.Minus, 0); }
		public ITerminalNode Eq() { return GetToken(VeeParser.Eq, 0); }
		public ITerminalNode Neq() { return GetToken(VeeParser.Neq, 0); }
		public ITerminalNode AndAlso() { return GetToken(VeeParser.AndAlso, 0); }
		public ITerminalNode OrElse() { return GetToken(VeeParser.OrElse, 0); }
		public ITerminalNode Gte() { return GetToken(VeeParser.Gte, 0); }
		public ITerminalNode Gt() { return GetToken(VeeParser.Gt, 0); }
		public ITerminalNode Lt() { return GetToken(VeeParser.Lt, 0); }
		public ITerminalNode Lte() { return GetToken(VeeParser.Lte, 0); }
		public ITerminalNode Concat() { return GetToken(VeeParser.Concat, 0); }
		public BinaryOperatorsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryOperators; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryOperators(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BinaryOperatorsContext binaryOperators() {
		BinaryOperatorsContext _localctx = new BinaryOperatorsContext(Context, State);
		EnterRule(_localctx, 56, RULE_binaryOperators);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 501;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Pow) | (1L << Multiply) | (1L << Divide) | (1L << Modulo) | (1L << Plus) | (1L << Minus) | (1L << Eq) | (1L << Neq) | (1L << Lt) | (1L << Gt) | (1L << Lte) | (1L << Gte) | (1L << Concat) | (1L << AndAlso) | (1L << OrElse))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryOperatorsContext : ParserRuleContext {
		public ITerminalNode Minus() { return GetToken(VeeParser.Minus, 0); }
		public ITerminalNode Not() { return GetToken(VeeParser.Not, 0); }
		public UnaryOperatorsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryOperators; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVeeVisitor<TResult> typedVisitor = visitor as IVeeVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryOperators(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryOperatorsContext unaryOperators() {
		UnaryOperatorsContext _localctx = new UnaryOperatorsContext(Context, State);
		EnterRule(_localctx, 58, RULE_unaryOperators);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 503;
			_la = TokenStream.LA(1);
			if ( !(_la==Minus || _la==Not) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return type_sempred((TypeContext)_localctx, predIndex);
		case 4: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool type_sempred(TypeContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 3);
		case 1: return Precpred(Context, 2);
		case 2: return Precpred(Context, 1);
		case 3: return Precpred(Context, 4);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 14);
		case 5: return Precpred(Context, 13);
		case 6: return Precpred(Context, 12);
		case 7: return Precpred(Context, 11);
		case 8: return Precpred(Context, 10);
		case 9: return Precpred(Context, 9);
		case 10: return Precpred(Context, 8);
		case 11: return Precpred(Context, 7);
		case 12: return Precpred(Context, 6);
		case 13: return Precpred(Context, 5);
		case 14: return Precpred(Context, 20);
		case 15: return Precpred(Context, 19);
		}
		return true;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x46");
		sb.Append("\x1FC\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6");
		sb.Append("\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r");
		sb.Append("\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12");
		sb.Append("\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4");
		sb.Append("\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B");
		sb.Append("\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x3\x2\x3");
		sb.Append("\x2\x3\x2\x5\x2\x42\n\x2\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3");
		sb.Append("\x3\x3\x3\x3\x3\x3\x5\x3M\n\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3");
		sb.Append("\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3");
		sb.Append("]\n\x3\f\x3\xE\x3`\v\x3\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x6\x6n\n\x6\r\x6\xE\x6");
		sb.Append("o\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\a\x6x\n\x6\f\x6\xE\x6");
		sb.Append("{\v\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\x83\n\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\x8B\n\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\a\x6\xA7\n\x6\f\x6\xE\x6\xAA\v\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\xB3\n\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\a\x6\xB8\n\x6\f\x6\xE\x6\xBB\v\x6\x3\x6\x3\x6\x5");
		sb.Append("\x6\xBF\n\x6\x5\x6\xC1\n\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x5\x6\xE7\n\x6\x3\x6\x3\x6\a\x6\xEB\n\x6\f\x6\xE\x6\xEE");
		sb.Append("\v\x6\x3\x6\a\x6\xF1\n\x6\f\x6\xE\x6\xF4\v\x6\x3\a\x3\a\x3\b");
		sb.Append("\x3\b\x3\b\x3\b\x3\b\x5\b\xFD\n\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3");
		sb.Append("\t\x3\n\x3\n\x3\n\a\n\x108\n\n\f\n\xE\n\x10B\v\n\x3\v\x3\v\x3");
		sb.Append("\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\a");
		sb.Append("\r\x11B\n\r\f\r\xE\r\x11E\v\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE");
		sb.Append("\x5\xE\x125\n\xE\x3\xF\x3\xF\x5\xF\x129\n\xF\x3\xF\x3\xF\x5");
		sb.Append("\xF\x12D\n\xF\x3\x10\x3\x10\x3\x10\x3\x10\a\x10\x133\n\x10\f");
		sb.Append("\x10\xE\x10\x136\v\x10\x3\x10\x5\x10\x139\n\x10\x3\x11\x3\x11");
		sb.Append("\x5\x11\x13D\n\x11\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12");
		sb.Append("\x3\x12\x6\x12\x146\n\x12\r\x12\xE\x12\x147\x3\x12\x3\x12\x3");
		sb.Append("\x12\x3\x12\x5\x12\x14E\n\x12\x3\x12\x3\x12\x3\x12\a\x12\x153");
		sb.Append("\n\x12\f\x12\xE\x12\x156\v\x12\x3\x12\x5\x12\x159\n\x12\x3\x13");
		sb.Append("\x3\x13\x3\x13\x3\x14\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3");
		sb.Append("\x15\x5\x15\x165\n\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3");
		sb.Append("\x16\x3\x16\a\x16\x16E\n\x16\f\x16\xE\x16\x171\v\x16\x3\x16");
		sb.Append("\x3\x16\x5\x16\x175\n\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16");
		sb.Append("\x3\x16\a\x16\x17D\n\x16\f\x16\xE\x16\x180\v\x16\x3\x16\x3\x16");
		sb.Append("\x5\x16\x184\n\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x18A\n");
		sb.Append("\x16\x3\x16\x3\x16\a\x16\x18E\n\x16\f\x16\xE\x16\x191\v\x16");
		sb.Append("\x3\x16\x3\x16\x5\x16\x195\n\x16\x3\x16\x3\x16\x3\x16\x5\x16");
		sb.Append("\x19A\n\x16\x3\x16\x3\x16\a\x16\x19E\n\x16\f\x16\xE\x16\x1A1");
		sb.Append("\v\x16\x3\x16\x3\x16\x5\x16\x1A5\n\x16\x3\x16\x3\x16\x3\x16");
		sb.Append("\x3\x16\x3\x16\x5\x16\x1AC\n\x16\x3\x17\x3\x17\x3\x17\x3\x17");
		sb.Append("\x5\x17\x1B2\n\x17\x5\x17\x1B4\n\x17\x3\x18\x3\x18\x3\x18\x3");
		sb.Append("\x18\x3\x18\x5\x18\x1BB\n\x18\x3\x19\x3\x19\x3\x19\x3\x19\x3");
		sb.Append("\x1A\x3\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x1C8\n");
		sb.Append("\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x1CD\n\x1B\a\x1B\x1CF\n\x1B");
		sb.Append("\f\x1B\xE\x1B\x1D2\v\x1B\x3\x1B\x5\x1B\x1D5\n\x1B\x3\x1C\x5");
		sb.Append("\x1C\x1D8\n\x1C\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3");
		sb.Append("\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x5\x1D\x1E6\n\x1D\x3");
		sb.Append("\x1D\x3\x1D\x3\x1D\x5\x1D\x1EB\n\x1D\x3\x1D\x3\x1D\x3\x1D\x3");
		sb.Append("\x1D\x3\x1D\x5\x1D\x1F2\n\x1D\x3\x1D\x3\x1D\x5\x1D\x1F6\n\x1D");
		sb.Append("\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x2\x4\x4\n \x2\x4\x6\b\n");
		sb.Append("\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \"$&(*,.\x30\x32\x34\x36");
		sb.Append("\x38:<\x2\xE\x3\x2\x33=\x3\x2\x12\x13\x3\x2\xF\x11\x3\x2\x14");
		sb.Append("\x15\x3\x2\x16\x19\x3\x2#$\x3\x2 !\x3\x2\x1E\x1F\x5\x2./\x42");
		sb.Append("\x42\x45\x45\x4\x2>>@\x41\x5\x2\xE\x19\x1D\x1D#$\x4\x2\x13\x13");
		sb.Append("%%\x23A\x2\x41\x3\x2\x2\x2\x4L\x3\x2\x2\x2\x6\x61\x3\x2\x2\x2");
		sb.Append("\b\x64\x3\x2\x2\x2\n\xC0\x3\x2\x2\x2\f\xF5\x3\x2\x2\x2\xE\xF7");
		sb.Append("\x3\x2\x2\x2\x10\x100\x3\x2\x2\x2\x12\x104\x3\x2\x2\x2\x14\x10C");
		sb.Append("\x3\x2\x2\x2\x16\x112\x3\x2\x2\x2\x18\x117\x3\x2\x2\x2\x1A\x124");
		sb.Append("\x3\x2\x2\x2\x1C\x12C\x3\x2\x2\x2\x1E\x12E\x3\x2\x2\x2 \x13C");
		sb.Append("\x3\x2\x2\x2\"\x158\x3\x2\x2\x2$\x15A\x3\x2\x2\x2&\x15D\x3\x2");
		sb.Append("\x2\x2(\x161\x3\x2\x2\x2*\x1AB\x3\x2\x2\x2,\x1B3\x3\x2\x2\x2");
		sb.Append(".\x1B5\x3\x2\x2\x2\x30\x1BC\x3\x2\x2\x2\x32\x1C0\x3\x2\x2\x2");
		sb.Append("\x34\x1D4\x3\x2\x2\x2\x36\x1D7\x3\x2\x2\x2\x38\x1F5\x3\x2\x2");
		sb.Append("\x2:\x1F7\x3\x2\x2\x2<\x1F9\x3\x2\x2\x2>?\x5\x1E\x10\x2?@\a");
		sb.Append("(\x2\x2@\x42\x3\x2\x2\x2\x41>\x3\x2\x2\x2\x41\x42\x3\x2\x2\x2");
		sb.Append("\x42\x43\x3\x2\x2\x2\x43\x44\x5\n\x6\x2\x44\x45\a\x2\x2\x3\x45");
		sb.Append("\x3\x3\x2\x2\x2\x46G\b\x3\x1\x2GM\x5\b\x5\x2HM\a\x43\x2\x2I");
		sb.Append("M\a\x44\x2\x2JK\a\x43\x2\x2KM\x5\x6\x4\x2L\x46\x3\x2\x2\x2L");
		sb.Append("H\x3\x2\x2\x2LI\x3\x2\x2\x2LJ\x3\x2\x2\x2M^\x3\x2\x2\x2NO\f");
		sb.Append("\x5\x2\x2OP\a\f\x2\x2P]\x5\x4\x3\x6QR\f\x4\x2\x2RS\a\t\x2\x2");
		sb.Append("S]\x5\x4\x3\x5TU\f\x3\x2\x2UV\a\x1A\x2\x2V]\x5\x4\x3\x4WX\f");
		sb.Append("\x6\x2\x2XY\a\a\x2\x2YZ\x5\x4\x3\x2Z[\a\b\x2\x2[]\x3\x2\x2\x2");
		sb.Append("\\N\x3\x2\x2\x2\\Q\x3\x2\x2\x2\\T\x3\x2\x2\x2\\W\x3\x2\x2\x2");
		sb.Append("]`\x3\x2\x2\x2^\\\x3\x2\x2\x2^_\x3\x2\x2\x2_\x5\x3\x2\x2\x2");
		sb.Append("`^\x3\x2\x2\x2\x61\x62\a\n\x2\x2\x62\x63\x5\x4\x3\x2\x63\a\x3");
		sb.Append("\x2\x2\x2\x64\x65\t\x2\x2\x2\x65\t\x3\x2\x2\x2\x66g\b\x6\x1");
		sb.Append("\x2g\xC1\x5\f\a\x2h\xC1\a\x43\x2\x2ij\a\a\x2\x2jm\x5\n\x6\x2");
		sb.Append("kl\a\t\x2\x2ln\x5\n\x6\x2mk\x3\x2\x2\x2no\x3\x2\x2\x2om\x3\x2");
		sb.Append("\x2\x2op\x3\x2\x2\x2pq\x3\x2\x2\x2qr\a\b\x2\x2r\xC1\x3\x2\x2");
		sb.Append("\x2st\a\x5\x2\x2ty\x5\x10\t\x2uv\a\t\x2\x2vx\x5\x10\t\x2wu\x3");
		sb.Append("\x2\x2\x2x{\x3\x2\x2\x2yw\x3\x2\x2\x2yz\x3\x2\x2\x2z|\x3\x2");
		sb.Append("\x2\x2{y\x3\x2\x2\x2|}\a\x6\x2\x2}\xC1\x3\x2\x2\x2~\x82\a\x5");
		sb.Append("\x2\x2\x7F\x83\x5\x12\n\x2\x80\x83\x5\x16\f\x2\x81\x83\x3\x2");
		sb.Append("\x2\x2\x82\x7F\x3\x2\x2\x2\x82\x80\x3\x2\x2\x2\x82\x81\x3\x2");
		sb.Append("\x2\x2\x83\x84\x3\x2\x2\x2\x84\xC1\a\x6\x2\x2\x85\x8A\a\x3\x2");
		sb.Append("\x2\x86\x8B\x5\xE\b\x2\x87\x8B\x5\x18\r\x2\x88\x8B\x5\x4\x3");
		sb.Append("\x2\x89\x8B\x3\x2\x2\x2\x8A\x86\x3\x2\x2\x2\x8A\x87\x3\x2\x2");
		sb.Append("\x2\x8A\x88\x3\x2\x2\x2\x8A\x89\x3\x2\x2\x2\x8B\x8C\x3\x2\x2");
		sb.Append("\x2\x8C\xC1\a\x4\x2\x2\x8D\x8E\a\a\x2\x2\x8E\x8F\x5\n\x6\x2");
		sb.Append("\x8F\x90\a\b\x2\x2\x90\xC1\x3\x2\x2\x2\x91\x92\a%\x2\x2\x92");
		sb.Append("\xC1\x5\n\x6\x14\x93\x94\a\"\x2\x2\x94\xC1\x5\n\x6\x13\x95\x96");
		sb.Append("\t\x3\x2\x2\x96\xC1\x5\n\x6\x12\x97\x98\a&\x2\x2\x98\xC1\x5");
		sb.Append("\n\x6\x11\x99\x9A\a\x1A\x2\x2\x9A\x9B\x5\x38\x1D\x2\x9B\x9C");
		sb.Append("\a\x1A\x2\x2\x9C\xC1\x3\x2\x2\x2\x9D\x9E\a\r\x2\x2\x9E\x9F\x5");
		sb.Append("\x34\x1B\x2\x9F\xA0\a\f\x2\x2\xA0\xA1\x5\x36\x1C\x2\xA1\xC1");
		sb.Append("\x3\x2\x2\x2\xA2\xA3\a)\x2\x2\xA3\xA8\x5&\x14\x2\xA4\xA5\a\x1A");
		sb.Append("\x2\x2\xA5\xA7\x5&\x14\x2\xA6\xA4\x3\x2\x2\x2\xA7\xAA\x3\x2");
		sb.Append("\x2\x2\xA8\xA6\x3\x2\x2\x2\xA8\xA9\x3\x2\x2\x2\xA9\xAB\x3\x2");
		sb.Append("\x2\x2\xAA\xA8\x3\x2\x2\x2\xAB\xAC\a-\x2\x2\xAC\xAD\x5\n\x6");
		sb.Append("\x4\xAD\xC1\x3\x2\x2\x2\xAE\xAF\a)\x2\x2\xAF\xB0\x5\n\x6\x2");
		sb.Append("\xB0\xB2\a*\x2\x2\xB1\xB3\a\x1A\x2\x2\xB2\xB1\x3\x2\x2\x2\xB2");
		sb.Append("\xB3\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xB9\x5(\x15\x2\xB5");
		sb.Append("\xB6\a\x1A\x2\x2\xB6\xB8\x5(\x15\x2\xB7\xB5\x3\x2\x2\x2\xB8");
		sb.Append("\xBB\x3\x2\x2\x2\xB9\xB7\x3\x2\x2\x2\xB9\xBA\x3\x2\x2\x2\xBA");
		sb.Append("\xBE\x3\x2\x2\x2\xBB\xB9\x3\x2\x2\x2\xBC\xBD\a-\x2\x2\xBD\xBF");
		sb.Append("\x5\n\x6\x2\xBE\xBC\x3\x2\x2\x2\xBE\xBF\x3\x2\x2\x2\xBF\xC1");
		sb.Append("\x3\x2\x2\x2\xC0\x66\x3\x2\x2\x2\xC0h\x3\x2\x2\x2\xC0i\x3\x2");
		sb.Append("\x2\x2\xC0s\x3\x2\x2\x2\xC0~\x3\x2\x2\x2\xC0\x85\x3\x2\x2\x2");
		sb.Append("\xC0\x8D\x3\x2\x2\x2\xC0\x91\x3\x2\x2\x2\xC0\x93\x3\x2\x2\x2");
		sb.Append("\xC0\x95\x3\x2\x2\x2\xC0\x97\x3\x2\x2\x2\xC0\x99\x3\x2\x2\x2");
		sb.Append("\xC0\x9D\x3\x2\x2\x2\xC0\xA2\x3\x2\x2\x2\xC0\xAE\x3\x2\x2\x2");
		sb.Append("\xC1\xF2\x3\x2\x2\x2\xC2\xC3\f\x10\x2\x2\xC3\xC4\a\xE\x2\x2");
		sb.Append("\xC4\xF1\x5\n\x6\x11\xC5\xC6\f\xF\x2\x2\xC6\xC7\t\x4\x2\x2\xC7");
		sb.Append("\xF1\x5\n\x6\x10\xC8\xC9\f\xE\x2\x2\xC9\xCA\t\x3\x2\x2\xCA\xF1");
		sb.Append("\x5\n\x6\xF\xCB\xCC\f\r\x2\x2\xCC\xCD\t\x5\x2\x2\xCD\xF1\x5");
		sb.Append("\n\x6\xE\xCE\xCF\f\f\x2\x2\xCF\xD0\t\x6\x2\x2\xD0\xF1\x5\n\x6");
		sb.Append("\r\xD1\xD2\f\v\x2\x2\xD2\xD3\t\a\x2\x2\xD3\xF1\x5\n\x6\f\xD4");
		sb.Append("\xD5\f\n\x2\x2\xD5\xD6\a\x1D\x2\x2\xD6\xF1\x5\n\x6\v\xD7\xD8");
		sb.Append("\f\t\x2\x2\xD8\xD9\t\b\x2\x2\xD9\xF1\x5\n\x6\n\xDA\xDB\f\b\x2");
		sb.Append("\x2\xDB\xDC\t\t\x2\x2\xDC\xF1\x5\n\x6\t\xDD\xDE\f\a\x2\x2\xDE");
		sb.Append("\xDF\a\x1B\x2\x2\xDF\xF1\x5\n\x6\b\xE0\xE1\f\x16\x2\x2\xE1\xE2");
		sb.Append("\a\x1C\x2\x2\xE2\xF1\x5\x1A\xE\x2\xE3\xE4\f\x15\x2\x2\xE4\xE6");
		sb.Append("\a\a\x2\x2\xE5\xE7\x5\x1C\xF\x2\xE6\xE5\x3\x2\x2\x2\xE6\xE7");
		sb.Append("\x3\x2\x2\x2\xE7\xEC\x3\x2\x2\x2\xE8\xE9\a\t\x2\x2\xE9\xEB\x5");
		sb.Append("\x1C\xF\x2\xEA\xE8\x3\x2\x2\x2\xEB\xEE\x3\x2\x2\x2\xEC\xEA\x3");
		sb.Append("\x2\x2\x2\xEC\xED\x3\x2\x2\x2\xED\xEF\x3\x2\x2\x2\xEE\xEC\x3");
		sb.Append("\x2\x2\x2\xEF\xF1\a\b\x2\x2\xF0\xC2\x3\x2\x2\x2\xF0\xC5\x3\x2");
		sb.Append("\x2\x2\xF0\xC8\x3\x2\x2\x2\xF0\xCB\x3\x2\x2\x2\xF0\xCE\x3\x2");
		sb.Append("\x2\x2\xF0\xD1\x3\x2\x2\x2\xF0\xD4\x3\x2\x2\x2\xF0\xD7\x3\x2");
		sb.Append("\x2\x2\xF0\xDA\x3\x2\x2\x2\xF0\xDD\x3\x2\x2\x2\xF0\xE0\x3\x2");
		sb.Append("\x2\x2\xF0\xE3\x3\x2\x2\x2\xF1\xF4\x3\x2\x2\x2\xF2\xF0\x3\x2");
		sb.Append("\x2\x2\xF2\xF3\x3\x2\x2\x2\xF3\v\x3\x2\x2\x2\xF4\xF2\x3\x2\x2");
		sb.Append("\x2\xF5\xF6\t\n\x2\x2\xF6\r\x3\x2\x2\x2\xF7\xF8\a\x42\x2\x2");
		sb.Append("\xF8\xFC\a\v\x2\x2\xF9\xFA\t\x3\x2\x2\xFA\xFB\a\x42\x2\x2\xFB");
		sb.Append("\xFD\a\v\x2\x2\xFC\xF9\x3\x2\x2\x2\xFC\xFD\x3\x2\x2\x2\xFD\xFE");
		sb.Append("\x3\x2\x2\x2\xFE\xFF\a\x42\x2\x2\xFF\xF\x3\x2\x2\x2\x100\x101");
		sb.Append("\a\x43\x2\x2\x101\x102\a\n\x2\x2\x102\x103\x5\n\x6\x2\x103\x11");
		sb.Append("\x3\x2\x2\x2\x104\x109\x5\x14\v\x2\x105\x106\a\t\x2\x2\x106");
		sb.Append("\x108\x5\x14\v\x2\x107\x105\x3\x2\x2\x2\x108\x10B\x3\x2\x2\x2");
		sb.Append("\x109\x107\x3\x2\x2\x2\x109\x10A\x3\x2\x2\x2\x10A\x13\x3\x2");
		sb.Append("\x2\x2\x10B\x109\x3\x2\x2\x2\x10C\x10D\a\x3\x2\x2\x10D\x10E");
		sb.Append("\x5\n\x6\x2\x10E\x10F\a\x4\x2\x2\x10F\x110\a\n\x2\x2\x110\x111");
		sb.Append("\x5\n\x6\x2\x111\x15\x3\x2\x2\x2\x112\x113\a\x3\x2\x2\x113\x114");
		sb.Append("\x5\x4\x3\x2\x114\x115\a\x4\x2\x2\x115\x116\x5\x6\x4\x2\x116");
		sb.Append("\x17\x3\x2\x2\x2\x117\x11C\x5\n\x6\x2\x118\x119\a\t\x2\x2\x119");
		sb.Append("\x11B\x5\n\x6\x2\x11A\x118\x3\x2\x2\x2\x11B\x11E\x3\x2\x2\x2");
		sb.Append("\x11C\x11A\x3\x2\x2\x2\x11C\x11D\x3\x2\x2\x2\x11D\x19\x3\x2");
		sb.Append("\x2\x2\x11E\x11C\x3\x2\x2\x2\x11F\x120\a\x3\x2\x2\x120\x121");
		sb.Append("\x5\n\x6\x2\x121\x122\a\x4\x2\x2\x122\x125\x3\x2\x2\x2\x123");
		sb.Append("\x125\a\x43\x2\x2\x124\x11F\x3\x2\x2\x2\x124\x123\x3\x2\x2\x2");
		sb.Append("\x125\x1B\x3\x2\x2\x2\x126\x127\a\x43\x2\x2\x127\x129\a\n\x2");
		sb.Append("\x2\x128\x126\x3\x2\x2\x2\x128\x129\x3\x2\x2\x2\x129\x12A\x3");
		sb.Append("\x2\x2\x2\x12A\x12D\x5\n\x6\x2\x12B\x12D\a\x44\x2\x2\x12C\x128");
		sb.Append("\x3\x2\x2\x2\x12C\x12B\x3\x2\x2\x2\x12D\x1D\x3\x2\x2\x2\x12E");
		sb.Append("\x12F\a\'\x2\x2\x12F\x134\x5 \x11\x2\x130\x131\a\t\x2\x2\x131");
		sb.Append("\x133\x5 \x11\x2\x132\x130\x3\x2\x2\x2\x133\x136\x3\x2\x2\x2");
		sb.Append("\x134\x132\x3\x2\x2\x2\x134\x135\x3\x2\x2\x2\x135\x138\x3\x2");
		sb.Append("\x2\x2\x136\x134\x3\x2\x2\x2\x137\x139\a\t\x2\x2\x138\x137\x3");
		sb.Append("\x2\x2\x2\x138\x139\x3\x2\x2\x2\x139\x1F\x3\x2\x2\x2\x13A\x13D");
		sb.Append("\a\x43\x2\x2\x13B\x13D\x5\"\x12\x2\x13C\x13A\x3\x2\x2\x2\x13C");
		sb.Append("\x13B\x3\x2\x2\x2\x13D\x13E\x3\x2\x2\x2\x13E\x13F\a\n\x2\x2");
		sb.Append("\x13F\x140\x5\n\x6\x2\x140!\x3\x2\x2\x2\x141\x142\a\a\x2\x2");
		sb.Append("\x142\x145\a\x43\x2\x2\x143\x144\a\t\x2\x2\x144\x146\a\x43\x2");
		sb.Append("\x2\x145\x143\x3\x2\x2\x2\x146\x147\x3\x2\x2\x2\x147\x145\x3");
		sb.Append("\x2\x2\x2\x147\x148\x3\x2\x2\x2\x148\x149\x3\x2\x2\x2\x149\x159");
		sb.Append("\a\b\x2\x2\x14A\x14B\a\x5\x2\x2\x14B\x14D\a\x43\x2\x2\x14C\x14E");
		sb.Append("\x5$\x13\x2\x14D\x14C\x3\x2\x2\x2\x14D\x14E\x3\x2\x2\x2\x14E");
		sb.Append("\x154\x3\x2\x2\x2\x14F\x150\a\t\x2\x2\x150\x151\a\x43\x2\x2");
		sb.Append("\x151\x153\x5$\x13\x2\x152\x14F\x3\x2\x2\x2\x153\x156\x3\x2");
		sb.Append("\x2\x2\x154\x152\x3\x2\x2\x2\x154\x155\x3\x2\x2\x2\x155\x157");
		sb.Append("\x3\x2\x2\x2\x156\x154\x3\x2\x2\x2\x157\x159\a\x6\x2\x2\x158");
		sb.Append("\x141\x3\x2\x2\x2\x158\x14A\x3\x2\x2\x2\x159#\x3\x2\x2\x2\x15A");
		sb.Append("\x15B\a\x31\x2\x2\x15B\x15C\a\x43\x2\x2\x15C%\x3\x2\x2\x2\x15D");
		sb.Append("\x15E\x5\n\x6\x2\x15E\x15F\a,\x2\x2\x15F\x160\x5\n\x6\x2\x160");
		sb.Append("\'\x3\x2\x2\x2\x161\x164\x5*\x16\x2\x162\x163\a+\x2\x2\x163");
		sb.Append("\x165\x5\n\x6\x2\x164\x162\x3\x2\x2\x2\x164\x165\x3\x2\x2\x2");
		sb.Append("\x165\x166\x3\x2\x2\x2\x166\x167\a,\x2\x2\x167\x168\x5\n\x6");
		sb.Append("\x2\x168)\x3\x2\x2\x2\x169\x16A\a\a\x2\x2\x16A\x16F\x5,\x17");
		sb.Append("\x2\x16B\x16C\a\t\x2\x2\x16C\x16E\x5,\x17\x2\x16D\x16B\x3\x2");
		sb.Append("\x2\x2\x16E\x171\x3\x2\x2\x2\x16F\x16D\x3\x2\x2\x2\x16F\x170");
		sb.Append("\x3\x2\x2\x2\x170\x174\x3\x2\x2\x2\x171\x16F\x3\x2\x2\x2\x172");
		sb.Append("\x173\a\t\x2\x2\x173\x175\x5\x32\x1A\x2\x174\x172\x3\x2\x2\x2");
		sb.Append("\x174\x175\x3\x2\x2\x2\x175\x176\x3\x2\x2\x2\x176\x177\a\b\x2");
		sb.Append("\x2\x177\x1AC\x3\x2\x2\x2\x178\x179\a\x5\x2\x2\x179\x17E\x5");
		sb.Append("\x30\x19\x2\x17A\x17B\a\t\x2\x2\x17B\x17D\x5\x30\x19\x2\x17C");
		sb.Append("\x17A\x3\x2\x2\x2\x17D\x180\x3\x2\x2\x2\x17E\x17C\x3\x2\x2\x2");
		sb.Append("\x17E\x17F\x3\x2\x2\x2\x17F\x183\x3\x2\x2\x2\x180\x17E\x3\x2");
		sb.Append("\x2\x2\x181\x182\a\t\x2\x2\x182\x184\x5\x32\x1A\x2\x183\x181");
		sb.Append("\x3\x2\x2\x2\x183\x184\x3\x2\x2\x2\x184\x185\x3\x2\x2\x2\x185");
		sb.Append("\x186\a\x6\x2\x2\x186\x1AC\x3\x2\x2\x2\x187\x189\a\x3\x2\x2");
		sb.Append("\x188\x18A\x5,\x17\x2\x189\x188\x3\x2\x2\x2\x189\x18A\x3\x2");
		sb.Append("\x2\x2\x18A\x18F\x3\x2\x2\x2\x18B\x18C\a\t\x2\x2\x18C\x18E\x5");
		sb.Append(",\x17\x2\x18D\x18B\x3\x2\x2\x2\x18E\x191\x3\x2\x2\x2\x18F\x18D");
		sb.Append("\x3\x2\x2\x2\x18F\x190\x3\x2\x2\x2\x190\x194\x3\x2\x2\x2\x191");
		sb.Append("\x18F\x3\x2\x2\x2\x192\x193\a\t\x2\x2\x193\x195\x5\x32\x1A\x2");
		sb.Append("\x194\x192\x3\x2\x2\x2\x194\x195\x3\x2\x2\x2\x195\x196\x3\x2");
		sb.Append("\x2\x2\x196\x1AC\a\x4\x2\x2\x197\x199\a\x5\x2\x2\x198\x19A\x5");
		sb.Append(".\x18\x2\x199\x198\x3\x2\x2\x2\x199\x19A\x3\x2\x2\x2\x19A\x19F");
		sb.Append("\x3\x2\x2\x2\x19B\x19C\a\t\x2\x2\x19C\x19E\x5.\x18\x2\x19D\x19B");
		sb.Append("\x3\x2\x2\x2\x19E\x1A1\x3\x2\x2\x2\x19F\x19D\x3\x2\x2\x2\x19F");
		sb.Append("\x1A0\x3\x2\x2\x2\x1A0\x1A4\x3\x2\x2\x2\x1A1\x19F\x3\x2\x2\x2");
		sb.Append("\x1A2\x1A3\a\t\x2\x2\x1A3\x1A5\x5\x32\x1A\x2\x1A4\x1A2\x3\x2");
		sb.Append("\x2\x2\x1A4\x1A5\x3\x2\x2\x2\x1A5\x1A6\x3\x2\x2\x2\x1A6\x1AC");
		sb.Append("\a\x6\x2\x2\x1A7\x1A8\t\v\x2\x2\x1A8\x1AC\x5,\x17\x2\x1A9\x1AC");
		sb.Append("\a?\x2\x2\x1AA\x1AC\x5\f\a\x2\x1AB\x169\x3\x2\x2\x2\x1AB\x178");
		sb.Append("\x3\x2\x2\x2\x1AB\x187\x3\x2\x2\x2\x1AB\x197\x3\x2\x2\x2\x1AB");
		sb.Append("\x1A7\x3\x2\x2\x2\x1AB\x1A9\x3\x2\x2\x2\x1AB\x1AA\x3\x2\x2\x2");
		sb.Append("\x1AC+\x3\x2\x2\x2\x1AD\x1B4\a\x43\x2\x2\x1AE\x1B4\x5*\x16\x2");
		sb.Append("\x1AF\x1B1\x5\b\x5\x2\x1B0\x1B2\x5$\x13\x2\x1B1\x1B0\x3\x2\x2");
		sb.Append("\x2\x1B1\x1B2\x3\x2\x2\x2\x1B2\x1B4\x3\x2\x2\x2\x1B3\x1AD\x3");
		sb.Append("\x2\x2\x2\x1B3\x1AE\x3\x2\x2\x2\x1B3\x1AF\x3\x2\x2\x2\x1B4-");
		sb.Append("\x3\x2\x2\x2\x1B5\x1B6\a\x3\x2\x2\x1B6\x1B7\x5\f\a\x2\x1B7\x1BA");
		sb.Append("\a\x4\x2\x2\x1B8\x1B9\a\n\x2\x2\x1B9\x1BB\x5,\x17\x2\x1BA\x1B8");
		sb.Append("\x3\x2\x2\x2\x1BA\x1BB\x3\x2\x2\x2\x1BB/\x3\x2\x2\x2\x1BC\x1BD");
		sb.Append("\a\x43\x2\x2\x1BD\x1BE\a\n\x2\x2\x1BE\x1BF\x5,\x17\x2\x1BF\x31");
		sb.Append("\x3\x2\x2\x2\x1C0\x1C1\a\v\x2\x2\x1C1\x1C2\a\x43\x2\x2\x1C2");
		sb.Append("\x33\x3\x2\x2\x2\x1C3\x1D5\a\x43\x2\x2\x1C4\x1C5\a\a\x2\x2\x1C5");
		sb.Append("\x1C7\a\x43\x2\x2\x1C6\x1C8\x5\x6\x4\x2\x1C7\x1C6\x3\x2\x2\x2");
		sb.Append("\x1C7\x1C8\x3\x2\x2\x2\x1C8\x1D0\x3\x2\x2\x2\x1C9\x1CA\a\t\x2");
		sb.Append("\x2\x1CA\x1CC\a\x43\x2\x2\x1CB\x1CD\x5\x6\x4\x2\x1CC\x1CB\x3");
		sb.Append("\x2\x2\x2\x1CC\x1CD\x3\x2\x2\x2\x1CD\x1CF\x3\x2\x2\x2\x1CE\x1C9");
		sb.Append("\x3\x2\x2\x2\x1CF\x1D2\x3\x2\x2\x2\x1D0\x1CE\x3\x2\x2\x2\x1D0");
		sb.Append("\x1D1\x3\x2\x2\x2\x1D1\x1D3\x3\x2\x2\x2\x1D2\x1D0\x3\x2\x2\x2");
		sb.Append("\x1D3\x1D5\a\b\x2\x2\x1D4\x1C3\x3\x2\x2\x2\x1D4\x1C4\x3\x2\x2");
		sb.Append("\x2\x1D5\x35\x3\x2\x2\x2\x1D6\x1D8\x5\x1E\x10\x2\x1D7\x1D6\x3");
		sb.Append("\x2\x2\x2\x1D7\x1D8\x3\x2\x2\x2\x1D8\x1D9\x3\x2\x2\x2\x1D9\x1DA");
		sb.Append("\x5\n\x6\x2\x1DA\x37\x3\x2\x2\x2\x1DB\x1DC\a\x44\x2\x2\x1DC");
		sb.Append("\x1DD\x5:\x1E\x2\x1DD\x1DE\x5\n\x6\x2\x1DE\x1F6\x3\x2\x2\x2");
		sb.Append("\x1DF\x1E0\x5\n\x6\x2\x1E0\x1E1\x5:\x1E\x2\x1E1\x1E2\a\x44\x2");
		sb.Append("\x2\x1E2\x1F6\x3\x2\x2\x2\x1E3\x1E5\a\x44\x2\x2\x1E4\x1E6\x5");
		sb.Append("\x6\x4\x2\x1E5\x1E4\x3\x2\x2\x2\x1E5\x1E6\x3\x2\x2\x2\x1E6\x1E7");
		sb.Append("\x3\x2\x2\x2\x1E7\x1E8\x5:\x1E\x2\x1E8\x1EA\a\x44\x2\x2\x1E9");
		sb.Append("\x1EB\x5\x6\x4\x2\x1EA\x1E9\x3\x2\x2\x2\x1EA\x1EB\x3\x2\x2\x2");
		sb.Append("\x1EB\x1F6\x3\x2\x2\x2\x1EC\x1ED\x5<\x1F\x2\x1ED\x1EE\a\x44");
		sb.Append("\x2\x2\x1EE\x1F6\x3\x2\x2\x2\x1EF\x1F1\a\x44\x2\x2\x1F0\x1F2");
		sb.Append("\x5\x6\x4\x2\x1F1\x1F0\x3\x2\x2\x2\x1F1\x1F2\x3\x2\x2\x2\x1F2");
		sb.Append("\x1F3\x3\x2\x2\x2\x1F3\x1F4\a\x1C\x2\x2\x1F4\x1F6\x5\x1A\xE");
		sb.Append("\x2\x1F5\x1DB\x3\x2\x2\x2\x1F5\x1DF\x3\x2\x2\x2\x1F5\x1E3\x3");
		sb.Append("\x2\x2\x2\x1F5\x1EC\x3\x2\x2\x2\x1F5\x1EF\x3\x2\x2\x2\x1F6\x39");
		sb.Append("\x3\x2\x2\x2\x1F7\x1F8\t\f\x2\x2\x1F8;\x3\x2\x2\x2\x1F9\x1FA");
		sb.Append("\t\r\x2\x2\x1FA=\x3\x2\x2\x2\x38\x41L\\^oy\x82\x8A\xA8\xB2\xB9");
		sb.Append("\xBE\xC0\xE6\xEC\xF0\xF2\xFC\x109\x11C\x124\x128\x12C\x134\x138");
		sb.Append("\x13C\x147\x14D\x154\x158\x164\x16F\x174\x17E\x183\x189\x18F");
		sb.Append("\x194\x199\x19F\x1A4\x1AB\x1B1\x1B3\x1BA\x1C7\x1CC\x1D0\x1D4");
		sb.Append("\x1D7\x1E5\x1EA\x1F1\x1F5");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());


}
